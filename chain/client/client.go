package client

import (
	"crypto/ecdsa"
	"math/big"

	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/common"
)

// ChainConfiguration is the necessary config for block chain client
// use to set up connections to RPC nodes
type ChainConfiguration struct {
	ChainID        *big.Int
	ChainName      string
	ChainLogo      string
	Currency       string
	Endpoints      []string
	SupportEIP1559 bool
	APIKey         string // for tron only, trongrid need a api key
}

type EventLog struct {
	Address string
	Topics  [][]byte
	Data    []byte
	Removed bool
}

type TxGasInfo struct {
	Fee      *big.Int
	GasPrice *big.Int
	GasUsed  *big.Int
}

type TransactionInfo struct {
	Tx        *Transaction
	Logs      []*EventLog
	IsPending bool
	Status    uint64
	Gas       *TxGasInfo
	Error     string
}

const (
	TransactionStatusFailed uint64 = iota
	TransactionStatusSuccess
	TransactionStatusInvalid
)

// Transaction is the transaction structure for different chains
// Contract is the contract address, such as "0xdac17f958d2ee523a2206206994597c13d831ec7" for USDT
// Method is the method name in the contract, such as 'transfer'
// From is transfer's source address
// To is the transfer's destination address
// Amount is the amount of tokens to be transfered, the unit is defined by contract
// Fee is defined in FeeLimit
type Transaction struct {
	Method string
	ABI    string
	From   string
	To     string
	Amount *big.Int
	Fee    *FeeLimit
	Nonce  uint64
	// ChainID is used to verify signature, so only needed when need to sign and broadcast a message
	ChainID *big.Int
	Data    []byte
}

// FeeLimit is the fee for executing transactions
// GasFeeCap is the total price of gas, which is the maximum value of (GasTipCap + BaseFee)
// GasTipCap is the tip price of gas
// actual gas price should be min(GasFeeCap, GasTipCap + BaseFee), BaseFee is the bas price of gas which is decided by current block
// Gas is the gas limit
// For platforms that are simpler than this model, TipPrice can will be 0
type FeeLimit struct {
	Gas       *big.Int
	GasFeeCap *big.Int
	GasTipCap *big.Int
}

// BlockChainClient defines the methods for working with different block chains
type BlockChainClient interface {
	// BalanceAt Account related
	BalanceAt(address string) (*big.Int, error)

	// BalanceOf ERC20 related
	BalanceOf(contract, from string) (*big.Int, error)
	DecimalsOf(contract string) (uint8, error)
	TotalSupplyOf(contract string) (*big.Int, error)
	SymbolOf(contract string) (string, error)
	GetNonce(address string) (uint64, error)
	GetNonceByNumber(address string, blockNumber *big.Int) (uint64, error)
	Allowance(contract, owner, spender string) (*big.Int, error)
	TransferData(to string, amount *big.Int) ([]byte, error)
	ApproveData(contract, owner, spender string, amount *big.Int) ([]byte, error)

	AbiConvertToInt(v interface{}) *big.Int
	AbiConvertToString(v interface{}) string
	AbiConvertToBytes(v interface{}) []byte
	AbiConvertToAddress(v interface{}) string

	// GetTransactionData generate the data part of a transaction
	// Example will be:
	// data, err := client.GetTransactionData("balanceOf", "erc20", address)
	// td := TransactionData{}
	// td.Data = data
	// tx, hash, err := client.GetTransaction(td)
	// signature := GenerateSignature(hash)
	// err := client.BroadcastTransaction(tx, signature)
	// or
	// result, err := client.CallContract(td)
	// fields, err := UnpackByABI(result)
	GetTransactionData(method string, abi string, args ...interface{}) (data []byte, err error)

	// RegisterABI registered the abi and can be reused for the future
	RegisterABI(name, abiStr string) error
	GetABIByName(name string) (*abi.ABI, error)

	// GetTransactionDataByABI is smiliar with GetTransactionData but reuse the registered ABI
	GetTransactionDataByABI(method, abiName string, args ...interface{}) (data []byte, err error)

	// UnpackByABI parse the result for the method call
	UnpackByABI(method, name string, data []byte) ([]interface{}, error)

	// GetSuggestFee returns the fee suggestion for a transaction
	// the Data field of Transaction needs to be generated by GetTransactionData
	GetSuggestFee(td *Transaction) (*FeeLimit, error)
	EstimateGas(td *Transaction) (uint64, error)

	// GetGasPrice returns the gas price for a transaction
	GetGasPrice() (*big.Int, *big.Int, error)

	// GetSuggestGasPrice returns the suggest gas price for a transaction && return the latest block's base fee
	GetSuggestGasPrice() (*big.Int, *big.Int, *big.Int, error)

	// DeployContract generates the transaction data to deploy a contract
	DeployContract(contractAbi, contractBin string, td *Transaction) (transaction []byte, hash []byte, contractAddress string, err error)

	// GetTransaction generates the transaction and hash to sign
	GetTransaction(td *Transaction) (transaction []byte, transHash []byte, err error)

	// BroadcastTransaction will broadcast the transaction to blockchain
	BroadcastTransaction(trans []byte, signature []byte) ([]byte, error)

	// CallContract will execute the call in VM but not generate transaction
	CallContract(td *Transaction) ([]byte, error)

	// GetTransactionByHash returns the transaction information, which includes:
	// - Status
	// - Transaction information (From, To, Data)
	// - Event logs
	GetTransactionByHash(transactionHash string) (*TransactionInfo, error)
	GetLatestBlockNumber() (*big.Int, error)

	// ParseEventLog parses the event log in transaction into fields
	ParseEventLog(abiName string, eventLog *EventLog) ([]interface{}, error)

	// AddressFromPrivateKey AddressForPRivateKey calculate the address for this key the privateKey here is hexed form, can with or without heading 0x
	AddressFromPrivateKey(privateKey string) (string, error)
	AddressFromPublicKey(pubKey *ecdsa.PublicKey) (string, error)

	AddressFromString(addr string) (common.Address, error)
	AddressToString(addr common.Address) string

	ContractAddress(addr common.Address) (bool, error)

	// IsValidAddress check if the address is valid
	IsValidAddress(address string) bool
	IsNativeAsset(address string) bool
	NativeAssetAddress() string
	// PublicKeyHexToAddress convert a generated public key from 65 bytes to address for the blockchain
	PublicKeyHexToAddress(publicKey string) (string, error)
	// NormalizeAddress unify the address format
	NormalizeAddress(address string) string
	NativeAssetDecimals() uint8
}
